<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dashboard - Koinonia</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script type="module">
        // Import Firebase modules
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
        import { getAuth, signOut } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js';
        import { getFirestore, doc, getDoc, collection, query, where, getDocs, addDoc, updateDoc, serverTimestamp, Timestamp, increment } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';

        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyC9ikNYt8QnD6FHm1MOq11HB0kTP_X8qNQ",
            authDomain: "wealth-club-65dab.firebaseapp.com",
            projectId: "wealth-club-65dab",
            storageBucket: "wealth-club-65dab.firebasestorage.app",
            messagingSenderId: "906138407714",
            appId: "1:906138407714:web:78e002acd44d2af326cb7b",
            measurementId: "G-8H8CZ65956"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);

        let currentUser = null;

        // Check authentication on page load
        document.addEventListener('DOMContentLoaded', function() {
            const userData = localStorage.getItem('currentUser');
            if (!userData) {
                window.location.href = 'login.html';
                return;
            }

            currentUser = JSON.parse(userData);
            document.getElementById('userName').textContent = currentUser.name;
            loadDashboardData();
        });

        // Load dashboard data
        async function loadDashboardData() {
            if (!currentUser) return;

            try {
                const userDocRef = doc(db, 'users', currentUser.uid);
                const userDoc = await getDoc(userDocRef);
                
                if (userDoc.exists()) {
                    const userData = userDoc.data();
                    currentUser = { uid: currentUser.uid, ...userData };
                    localStorage.setItem('currentUser', JSON.stringify(currentUser));
                    
                    document.getElementById('totalMavro').textContent = `$${(userData.mavroBalance || 0).toFixed(2)}`;
                    document.getElementById('accountStatus').textContent = userData.status || 'Active';
                }

                loadRecentActivity();
                loadTransactionQueue();
            } catch (error) {
                console.error('Error loading dashboard data:', error);
            }
        }

        // Load recent activity from mavroTransactions
        async function loadRecentActivity() {
            // This function remains unchanged
            const q = query(collection(db, 'mavroTransactions'), where('userId', '==', currentUser.uid));
            const querySnapshot = await getDocs(q);
            const activityContainer = document.getElementById('recentActivity');
            activityContainer.innerHTML = ''; 

            if (querySnapshot.empty) {
                activityContainer.innerHTML = '<p class="text-gray-500 text-center py-4">No recent activity.</p>';
                return;
            }

            querySnapshot.forEach((doc) => {
                const transaction = doc.data();
                const activityItem = createActivityItem(transaction);
                activityContainer.appendChild(activityItem);
            });
        }

        // Create a visual element for an activity item
        function createActivityItem(transaction) {
            // This function remains unchanged
            const div = document.createElement('div');
            div.className = 'flex items-center space-x-4 p-4 hover:bg-gray-50 rounded-lg transition-colors';
            
            const isCredit = transaction.amount > 0;
            const typeDetails = { bonus: { color: 'green', icon: 'üéÅ' }, provide: { color: 'blue', icon: 'ü§ù' }, get: { color: 'red', icon: 'üôè' }, growth: { color: 'purple', icon: 'üìà' } };
            const details = typeDetails[transaction.type] || { color: 'gray', icon: 'üí∞' };

            div.innerHTML = `
                <div class="w-10 h-10 bg-${details.color}-100 rounded-full flex items-center justify-center"><span class="text-xl">${details.icon}</span></div>
                <div class="flex-1"><p class="font-semibold text-gray-800">${transaction.description}</p><p class="text-gray-600 text-sm">${transaction.type.charAt(0).toUpperCase() + transaction.type.slice(1)}</p></div>
                <div class="text-right"><p class="font-bold text-${isCredit ? 'green' : 'red'}-600">${isCredit ? '+' : '-'}$${Math.abs(transaction.amount).toFixed(2)}</p><p class="text-gray-500 text-sm">${new Date(transaction.date).toLocaleDateString()}</p></div>
            `;
            return div;
        }

        // Load all user's active requests AND matches
        async function loadTransactionQueue() {
            // This function remains unchanged
            const queueContainer = document.getElementById('transactionQueue');
            queueContainer.innerHTML = ''; 

            const requestsQuery = query(collection(db, 'helpRequests'), where('userId', '==', currentUser.uid), where('status', '==', 'pending'));
            const requestsSnapshot = await getDocs(requestsQuery);
            requestsSnapshot.forEach(doc => queueContainer.appendChild(createQueueItem(doc.data())));

            const matchesProviderQuery = query(collection(db, 'matches'), where('providerId', '==', currentUser.uid), where('status', 'in', ['pending_payment', 'payment_sent']));
            const providerSnapshot = await getDocs(matchesProviderQuery);
            providerSnapshot.forEach(doc => queueContainer.appendChild(createMatchItem({ id: doc.id, ...doc.data() })));

            const matchesGetterQuery = query(collection(db, 'matches'), where('getterId', '==', currentUser.uid), where('status', 'in', ['pending_payment', 'payment_sent']));
            const getterSnapshot = await getDocs(matchesGetterQuery);
            getterSnapshot.forEach(doc => queueContainer.appendChild(createMatchItem({ id: doc.id, ...doc.data() })));

            if (queueContainer.innerHTML === '') {
                queueContainer.innerHTML = '<p class="text-gray-500 text-center py-4">No active orders in your queue.</p>';
            }
        }

        // Create a visual element for a PENDING request
        function createQueueItem(request) {
            // This function remains unchanged
            const div = document.createElement('div');
            const isProvide = request.type === 'provide';
            const color = isProvide ? 'yellow' : 'green';
            const title = isProvide ? 'Provide Help Request' : 'Get Help Request';
            const description = `Your request is ${request.status} and is waiting for an admin to match you.`;

            div.className = `flex items-center justify-between p-4 bg-${color}-50 rounded-lg border-l-4 border-${color}-400`;
            div.innerHTML = `
                <div><p class="font-semibold text-gray-800">${title}</p><p class="text-gray-600">${description}</p><p class="text-sm text-gray-500">Amount: $${request.amount.toFixed(2)}</p></div>
                <button class="bg-gray-500 text-white px-4 py-2 rounded-lg cursor-not-allowed">Pending Admin</button>
            `;
            return div;
        }

        // --- UPDATED: Create a visual element for a CONFIRMED match with a functional button ---
        function createMatchItem(match) {
            const div = document.createElement('div');
            const isProvider = match.providerId === currentUser.uid;
            const color = isProvider ? 'blue' : 'purple';
            const title = isProvider ? `You are matched to help ${match.getterName}` : `You will receive help from ${match.providerName}`;
            let description = `Status: ${match.status.replace('_', ' ')}.`;
            if (isProvider) description += " Click 'View Details' to get payment info.";
            else description += " Click 'View Details' to confirm reception.";

            div.className = `flex items-center justify-between p-4 bg-${color}-50 rounded-lg border-l-4 border-${color}-400`;
            div.innerHTML = `
                <div>
                    <p class="font-semibold text-gray-800">${title}</p>
                    <p class="text-gray-600">${description}</p>
                    <p class="text-sm text-gray-500">Amount: $${match.amount.toFixed(2)}</p>
                </div>
                <button onclick="viewMatchDetails('${match.id}')" class="bg-${color}-500 text-white px-4 py-2 rounded-lg hover:bg-${color}-600">
                    View Details
                </button>
            `;
            return div;
        }

        // --- NEW: Function to show match details in a modal ---
        window.viewMatchDetails = async function(matchId) {
            const matchDoc = await getDoc(doc(db, 'matches', matchId));
            if (!matchDoc.exists()) {
                alert("Match not found!");
                return;
            }
            const match = { id: matchId, ...matchDoc.data() };
            const isProvider = match.providerId === currentUser.uid;
            
            const modal = document.getElementById('matchModal');
            const modalContent = document.getElementById('modalContent');
            modalContent.innerHTML = ''; // Clear previous content

            if (isProvider) {
                // Fetch getter's payment details
                const bankAccountsQuery = query(collection(db, 'bankAccounts'), where('userId', '==', match.getterId));
                const bankAccountsSnapshot = await getDocs(bankAccountsQuery);
                let paymentDetailsHTML = '<h5>Bank Accounts:</h5>';
                bankAccountsSnapshot.forEach(doc => {
                    const acc = doc.data();
                    paymentDetailsHTML += `<div class="border p-2 my-2 rounded"><strong>Bank:</strong> ${acc.bankName}<br><strong>Account Number:</strong> ${acc.accountNumber}<br><strong>Type:</strong> ${acc.accountType}</div>`;
                });
                
                modalContent.innerHTML = `
                    <h3 class="text-lg font-bold mb-4">Payment Details for ${match.getterName}</h3>
                    <p class="mb-4">Please send exactly <strong>$${match.amount.toFixed(2)}</strong> using the details below and confirm when you have sent the payment.</p>
                    ${paymentDetailsHTML}
                    <div class="mt-4 flex justify-end gap-4">
                        <button onclick="closeModal()" class="bg-gray-300 px-4 py-2 rounded">Close</button>
                        <button onclick="confirmPaymentSent('${match.id}')" class="bg-blue-600 text-white px-4 py-2 rounded">I Have Sent The Payment</button>
                    </div>
                `;
            } else { // Is the getter
                modalContent.innerHTML = `
                    <h3 class="text-lg font-bold mb-4">Confirm Fund Reception</h3>
                    <p class="mb-4">You are matched to receive <strong>$${match.amount.toFixed(2)}</strong> from ${match.providerName}. Please click the button below ONLY after you have received the funds in your account.</p>
                    <div class="mt-4 flex justify-end gap-4">
                        <button onclick="closeModal()" class="bg-gray-300 px-4 py-2 rounded">Close</button>
                        <button onclick="confirmReception('${match.id}')" class="bg-green-600 text-white px-4 py-2 rounded">I Have Received The Funds</button>
                    </div>
                `;
            }
            modal.classList.remove('hidden');
        }

        // --- NEW: Function for the provider to confirm they've sent payment ---
        window.confirmPaymentSent = async function(matchId) {
            if (!confirm("Are you sure you have sent the payment?")) return;
            await updateDoc(doc(db, 'matches', matchId), { status: 'payment_sent' });
            alert("Confirmation sent. Please wait for the recipient to verify.");
            closeModal();
            loadTransactionQueue();
        }

        // --- NEW: Function for the getter to confirm they've received payment ---
        window.confirmReception = async function(matchId) {
            if (!confirm("Are you sure you have received the funds? This action cannot be undone.")) return;

            const matchDoc = await getDoc(doc(db, 'matches', matchId));
            if (!matchDoc.exists()) return alert("Match error!");
            
            const match = matchDoc.data();
            const growthAmount = match.amount * 1.30; // 30% growth

            // 1. Update the match status to completed
            await updateDoc(doc(db, 'matches', matchId), { status: 'completed' });

            // 2. Create the 'provide' transaction for the provider
            await addDoc(collection(db, 'mavroTransactions'), {
                userId: match.providerId,
                userName: match.providerName,
                type: 'provide',
                description: `Completed help of $${match.amount.toFixed(2)}`,
                amount: match.amount,
                status: 'completed',
                date: new Date().toISOString(),
                growthReleaseDate: new Date().toISOString() // Matures immediately
            });
            
            // 3. Create the 'growth' transaction for the provider
             await addDoc(collection(db, 'mavroTransactions'), {
                userId: match.providerId,
                userName: match.providerName,
                type: 'growth',
                description: `30% growth on $${match.amount.toFixed(2)}`,
                amount: match.amount * 0.30,
                status: 'completed',
                date: new Date().toISOString()
            });

            // 4. Update the provider's main balance in the users collection
            await updateDoc(doc(db, 'users', match.providerId), {
                mavroBalance: increment(growthAmount)
            });

            alert("Confirmation successful! The provider's account has been credited. Thank you for your participation.");
            closeModal();
            loadDashboardData();
        }

        // --- NEW: Utility functions for the modal ---
        window.closeModal = function() {
            document.getElementById('matchModal').classList.add('hidden');
        }


        // Provide Help function
        window.provideHelp = async function() {
            // This function remains unchanged
            const amountInput = prompt('How much would you like to provide? (Minimum $100)');
            if (!amountInput) return;
            const amount = parseFloat(amountInput);
            if (isNaN(amount) || amount < 100) { alert('Invalid amount. Minimum is $100.'); return; }
            try {
                await addDoc(collection(db, 'helpRequests'), { userId: currentUser.uid, userName: currentUser.name, type: 'provide', amount: amount, status: 'pending', createdAt: new Date().toISOString() });
                alert(`Your request to provide $${amount} has been submitted. It is now pending admin matching.`);
                loadDashboardData();
            } catch (error) { alert('Error creating request: ' + error.message); }
        };
        
        // Get Help function
        window.getHelp = async function() {
            // This function remains unchanged
             try {
                const mavroQuery = query(collection(db, 'mavroTransactions'), where('userId', '==', currentUser.uid));
                const mavroSnapshot = await getDocs(mavroQuery);
                let withdrawableBalance = 0;
                const now = new Date();
                mavroSnapshot.forEach(doc => {
                    const t = doc.data();
                    const releaseDate = new Date(t.growthReleaseDate || 0);
                    if ((t.type === 'provide' && t.status === 'completed' && releaseDate <= now) || ((t.type === 'bonus' || t.type === 'growth') && t.status === 'completed')) {
                       withdrawableBalance += t.amount;
                    } else if (t.type === 'get') {
                        withdrawableBalance -= Math.abs(t.amount); 
                    }
                });
                
                if (withdrawableBalance <= 0) {
                    alert("You have no matured and confirmed funds available for withdrawal. You can only request to get help after you have successfully provided help and it has matured.");
                    return;
                }

                const amountInput = prompt(`How much help do you need?\nYour maximum available balance is $${withdrawableBalance.toFixed(2)}.`);
                if (!amountInput) return;
                const amount = parseFloat(amountInput);
                if (isNaN(amount) || amount <= 0 || amount > withdrawableBalance) {
                    alert('Invalid amount. Please enter a value up to your available balance.');
                    return;
                }

                await addDoc(collection(db, 'helpRequests'), { userId: currentUser.uid, userName: currentUser.name, type: 'get', amount: amount, status: 'pending', createdAt: new Date().toISOString() });
                alert(`Your request for $${amount} has been submitted. Admin will verify your balance and process the match.`);
                loadDashboardData();
            } catch (error) {
                alert('Error creating get help request: ' + error.message);
            }
        };

        // Logout function
        window.logout = function() {
            // This function remains unchanged
            signOut(auth).then(() => {
                localStorage.removeItem('currentUser');
                localStorage.removeItem('isAdmin');
                window.location.href = 'index.html';
            }).catch((error) => {
                console.error('Error signing out:', error);
            });
        };
    </script>
</head>
<body>
    <!-- --- NEW: Modal Structure for Match Details --- -->
    <div id="matchModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden z-50">
        <div class="bg-white rounded-lg shadow-xl p-6 w-full max-w-md">
            <div id="modalContent">
                <!-- Dynamic content will be injected here -->
            </div>
        </div>
    </div>

    <div class="min-h-screen bg-gray-50">
        <!-- Header -->
        <header class="bg-white shadow-sm border-b">
             <!-- ... existing header html ... -->
        </header>

        <div class="flex">
            <!-- Sidebar -->
            <nav class="w-64 bg-white shadow-sm h-screen sticky top-0">
                <!-- ... existing sidebar html ... -->
            </nav>

            <!-- Main Content -->
            <main class="flex-1 p-6">
                <!-- Primary Action Buttons -->
                <div class="grid md:grid-cols-2 gap-6 mb-8">
                     <!-- ... existing buttons html ... -->
                </div>

                <!-- Account Summary -->
                <div class="bg-white rounded-2xl shadow-sm p-6 mb-8">
                    <!-- ... existing summary html ... -->
                </div>

                <!-- Transaction Queue -->
                <div class="bg-white rounded-2xl shadow-sm p-6 mb-8">
                    <h3 class="text-xl font-bold text-gray-800 mb-6">Active Orders & Requests</h3>
                    <div id="transactionQueue" class="space-y-4">
                        <!-- Dynamic queue items will be loaded here -->
                    </div>
                </div>

                <!-- Recent Activity -->
                <div class="bg-white rounded-2xl shadow-sm p-6">
                    <h3 class="text-xl font-bold text-gray-800 mb-6">Recent Activity</h3>
                    <div id="recentActivity" class="space-y-4">
                        <!-- Dynamic activity items will be loaded here -->
                    </div>
                </div>
            </main>
        </div>
    </div>
    <!-- The rest of your body content is assumed here -->
</body>
</html>
